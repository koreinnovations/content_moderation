<?
// $Id$

# Copyright (c) 2010 Impressive.media
# Author: Eugen Mayer

require_once('content_moderation.workflow.inc');
require_once('content_moderation.trigger.inc');
require_once('content_moderation.rules.inc');

/*
 * Implementation of hook_menu().
 */
function content_moderation_menu() {
  $items = array();
  $items["moderate/%node/%/change"] = array(
      'title' => 'Change moderation state',
      'type' => MENU_CALLBACK,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('content_moderation_change_state_form',2),
      'access callback' => '_content_moderation_statechange_allowed',
      'access arguments' => array(2)
  );
  $items["node/%node/moderation_history"] = array(
      'title' => 'Moderation history',
      'description' => t('Show the content moderation history.'),
      'type' => MENU_LOCAL_TASK,
      'page callback' => '_content_moderation_history',
      'page arguments' => array(1),
      'access callback' => '_content_moderation_access',
      'access arguments' => array('view history',1),
  );

  return $items;
}

/*
 * Implementation of hook_menu_alter
 */
function content_moderation_menu_alter(&$items) {
  // we need to get this wrapper in place, as we cant use the nodeapi "prepare" op
  // as module like taxonomy, files and so forth would not fetch the correct versions
  $items['node/%node/edit']['page callback'] = '_content_moderation_node_edit_page';
}

/*
 * Implementing hook_block
 */
function content_moderation_block($op = "list", $delta = 0, $edit = array()){
  switch($op) {
    case 'list':
      $blocks[0]['info'] = t('Content moderation info');
      return $blocks;
    break;
    case 'view':
      switch($delta) {
        case 0:
          $node = _content_moderation_get_current_viewed_node();
          // No need to show the block if the viewd node is not moderated. Questionable.
          if (!_content_moderation_moderate_node_type($node->type)) {
            return;
          }

          $live = _content_moderation_live_revision($node->nid);

          $m = drupal_get_path('module', 'content_moderation');
          drupal_add_css("$m/css/block.css");

          $latest = _content_moderation_get_latest_revisions($node->nid,5,NULL,array($node->vid));
          $revisions_list = theme('content_moderation_revisions_list',$latest);

          $state = ucfirst(_content_moderation_current_state($node->vid));
          // All kinds of actions we can do.
          $links['edit_revision'] = "node/{$node->nid}/revisions/{$node->vid}/edit";
          $links['delete_revision'] = "node/{$node->nid}/revisions/{$node->vid}/delete";
          $links['edit_live'] = "node/{$node->nid}/edit";
          $links['edit_state'] = _content_moderation_change_state_link($node->vid,$node->nid);
          $links['compare_with_live'] = "node/{$node->nid}/revisions/view/{$node->vid}/{$live->vid}";
          $links['compare'] = "node/{$node->nid}/revisions";
          $links['live_view'] = 'node/'.$live->nid;

          $block['subject'] = t("Revision");
          $block['content'] = theme('content_moderation_info_block',$node, $links, $state, $live_link, $live,$revisions_list);
          return $block;
        break;
      }
    break;
  }
}


/*
 * Implementation of hook_theme
 */
function content_moderation_theme() {
  return array(
    'content_moderation_info_block' => array(
      'template' => 'content_moderation_info_block',
      'arguments' => array('node' => NULL,'links' => NULL, 'state' => t('none'), 'live_link' => NULL, 'live' => NULL,'revisions_list' => ''),
    ),
    'content_moderation_node_history' => array(
     'arguments' => array('history' => array()),
    ),
    'content_moderation_revisions_list' => array(
      'template' => 'content_moderation_revisions_list',
      'arguments' => array('revisions' => NULL),
    ),
  );
}

/**
 * Implementation of hook_help().
 */
function content_moderation_help($path, $arg) {
  switch ($path) {
    case 'admin/help#content_moderation':
      return '<p>'. t("Enables you to moderate the creation of nodes and there further editing. You can have a 'Live version' for all visitors and pending revisions which need to be approved and become the new 'Live Version' then.") .'</p>';
  }
}

/*
 * Implementation of hook_nodeapi
 */
function content_moderation_nodeapi(&$node, $op, $a3, $a4) {
  global $user;
  $type = $node->type;
  if (!_content_moderation_moderate_node_type($type)) {
    // Dont moderate this content type
    return;
  }
  //dsm($op);
  switch ($op) {
    case 'presave':
      if ( empty($node->nid)) {
        // We backup the original data and use them in the insert hook later.
        $node->body_orig = $node->body;
        $node->teaser_orig = $node->teaser;
        $node->log_orig = $node->log;


        // lets call our alter hook to modify the fake-live version
        _content_moderation_get_modfiy_for_first_revision($node);
        // Now node_save gets called, saving this not into the database
        // and right after it, it calls nodapi using insert. Thats were we save
        // the original node content, which will be then a pending version.
      }
      else {
        $live = _content_moderation_live_revision($node->nid);
        $node->live_vid = $live->vid;
      }
      break;
    case 'insert':
      // We need to clone the node, otherwise later the grants will be assigned to that vid
      $node->live_vid = $node->vid;
      $node_real = drupal_clone($node);

      _content_moderation_create_pending_revision($node_real);
      // we need to restore the live version pointer, as node_save has been called
      // and it is automatically updating it
      db_query('UPDATE {node} SET vid = %d WHERE nid = %d', $node->live_vid, $node->nid);
      drupal_set_message(t("Your content has been saved as a pending revision. Click !here to view your revision.", array(
        '!here'=>l(t('here'), "node/$node->nid/revisions/".$node->vid.'/view')
      )), 'warning');
      break;
    case 'update':
      // This update api call was triggered by a node_save done in 'insert' of a creation
      // of a content_moderated node. This node_save is saving the real node as a revision
      // while the live one is just a template.
      if($node->content_moderation_update == true) {
        // We need to add some miliseconds to the timestamp, otherwise the fake version will be newer then
        // the real pending one
        db_query('UPDATE {node_revisions} SET timestamp = %d WHERE vid = %d',time() + 1, $node->vid);
      }
      else {
        // Force the live revision back to saved live -version.
        db_query('UPDATE {node} SET vid = %d WHERE nid = %d', $node->live_vid, $node->nid);
        drupal_set_message(t("Your content has been saved as a pending version. Click !here to view the live version.", array(
        '!here'=>l(t('here'), "node/".$node->nid)
        )), 'warning');
      }

      break;
    case 'view':
      $live = _content_moderation_live_revision($node->nid);
      $live_vid = $live->vid;

      if ($node->vid != $live_vid) {
        // Get username for the revision rather than the original node.
        $revision_author = user_load($node->revision_uid);
        drupal_set_message(
          t('The revision of this node has been created on @date by !author.',
            array(
             '@date'=>format_date($node->revision_timestamp, 'small'),
             '!author'=>theme('username', $revision_author)
            )
          )
        );
      }
      else {
        $count = db_result(db_query('select count(vid) from {node_revisions} where vid>%d and nid=%d',$node->vid,$node->nid));
        if($count == 1)
          drupal_set_message(t('This document has 1 pending revision',array('@count' => $count)));
        else if($count > 1) {
          drupal_set_message(t('This document has @count pending revisions',array('@count' => $count)));
        }
      }
      break;
  }
}

/*
 * Implementation of hook_perm.
 */
function content_moderation_perm() {
  // TODO: cache this
  // This user right is later used for granting the user the approval of pending version
  // making those version "live".
  $states = _content_moderation_states();
  $types = _content_moderation_moderate_node_types();

  $rigths = array();
  foreach($types as $type) {
    foreach($states as $from_state) {
        $to_states = _content_moderation_next_states($from_state,$type);
        // values are translated
        $to_states = array_keys($to_states);
        foreach($to_states as $to_state) {
          $rigths[] = "content moderation $type state '$from_state' to '$to_state'";
        }
    }
  }

  return $rigths;
}

/*
 * Call this method in the form_submit or presave methods to let the updated node
 * be the new live version.
 */
function content_moderation_reset_live_status($nid = NULL) {
  if ($nid == NULL || !is_numeric($nid)) {
    return;
  }

  db_query('DELETE from {content_moderation} WHERE nid = %d', $nid);
}

/*
 * Implementation of hook_modify_first_revision_alter
 */
function content_moderation_content_moderation_modify_first_revision_alter(&$node) {
  $node->body = t('Initial revision - this node is under moderation and no revision has been set live yet.');
  $node->log = t('Auto-creating live version as a template');
}

/*
 * Implementation of hook_form_alter
 */
function content_moderation_form_node_type_form_alter(&$form, $form_state) {
  $form[ 'workflow' ][ 'node_options' ][ '#options' ][ 'node_content_moderation' ] = t('Moderate revisions');
}

/*
 * Implementation of form_alter.
 * Forcing new reversion and publishing.
 */
function content_moderation_form_alter(&$form, $form_state, $form_id)  {
  if (!_content_moderation_moderate_node_type($form['#node']->type)) {
    // Dont moderate this content type.
    return;
  }

  if ($form['#id'] == 'node-form') {
    // force new revision
    $form['revision_information']['revision']['#prefix'] = t('As this content is in moderation, you cannot choose here. A new revision is always created.');
    $form['revision_information']['revision']['#disabled'] = true;
    $form['revision_information']['revision']['#default_value'] = true;
    $descr = t('You cant choose here, as this content is under moderation. Publishing is forced.');
    if(is_array($form['options']['status'])) {
      $form['options']['status']['#disabled'] = true;
      $form['options']['status']['#default_value'] = true;
      $form['options']['status']['#prefix'] = $descr;
      $form['options']['status']['#value'] = true;
    }
    if(module_exists('impressive_media_icombined_access')) {
      $form['custom_options']['status']['#disabled'] = true;
      $form['custom_options']['status']['#default_value'] = true;
      $form['custom_options']['status']['#value'] = true;
      $form['custom_options']['status']['#prefix'] = $descr;
    }
  }
}

/*
 * Implementation content_moderation_node_history
 * Theming the output of content moderations history table
 */
function theme_content_moderation_node_history($history) {
  $data = array();

  foreach($history as $e) {
    $user = user_load($e->uid);
    $state_class = "state_{$e->state_name}";
    // TODO: proper localized date format
    $data[] = array (
      date('d.m.y - h:i', $e->stamp),                         // date
      l($user->name,"user/{$user->uid}"),                     // Who changed that state?
      "<span class='$state_class'>".ucfirst(t($e->old_state_name)).' -> '.ucfirst(t($e->state_name)).'</span>',             // Transition
      l($e->vid,"node/{$e->nid}/revisions/{$e->vid}/view")   // revision
    );
  }

  return theme('table',
                array(
                      t('Date'),
                      t('Author'),
                      t('Transition'),
                      t('Revision'),
                    )
                ,$data);
}

/*
 * Needed by the views API
 */
function content_moderation_views_api() {
  return array('api' => 2.0);
}

/*
 * This is out small helper to ensure, that always the newes vid gets edited.
 * The normal node API would edit the vid which is currently in {node},
 * But we want to edit the VID which is the most recent one.
 */
function _content_moderation_node_edit_page($node) {
  if (_content_moderation_moderate_node_type($node->type)) {
    $vid =  _content_moderation_latest_revision($node->nid);
    // We only need to change the behavior if the current version is not the latest pending version
    if($node->vid != $vid) {
      $node = node_load($node->nid,$vid);
      drupal_set_message(t('You are now editing the most recent pending revision (@revision) and not the live version!',array('@revision' => $vid)),'warning');
    }
  }

  return node_page_edit($node);
}

/*
 * Fetch the revision data without using node_load to save some performance.
 */
function _content_moderation_revision_infos($vid) {
  $result = db_query('SELECT * FROM {node_revisions} WHERE vid=%d',$vid);
  return db_fetch_object($result);
}

/*
 * Calculated the most recent vid of the current node
 */
function _content_moderation_latest_revision($nid) {
  return db_result(db_query('SELECT MAX(vid) FROM {node_revisions} WHERE nid=%d',$nid));
}

/*
 * Generating a history overview of a node.
 */
function _content_moderation_history($node) {
  $m = drupal_get_path('module', 'content_moderation');
  drupal_add_css("$m/css/history.css");
  $history = _content_moderation_get_history(array('name' => 'nid', 'value' => $node->nid));
  drupal_set_title(t('History'));
  return theme('content_moderation_node_history',$history);
}

/*
 * Calling our alter hook.
 */
function _content_moderation_get_modfiy_for_first_revision(&$node) {
  //TODO: hooks / alter here
  drupal_alter('content_moderation_modify_first_revision', $node);
}

/*
 * Helper function for creating a new node.
 * Its creating a live version which is a placeholder and
 * moving the real content to a moderated revision
 */
function _content_moderation_create_pending_revision(&$node) {
  global $user;

  // as we saved the "fake live version" before in presave, lets save the original node here.
  $node->content_moderation_update = true;
  // We saved a "pending" version of the node first, lets restore the real content
  // and the real log message.
  $node->body = $node->body_orig;
  $node->teaser = $node->teaser_orig;
  $node->log = $node->log_orig;
  $node->vid = NULL;
  $node->created = NULL;

  // Yes we dont like non-api deep system calls. But we cant use node_save as
  // we would get into a loop.
  node_save($node);
}

/*
 * Returning the node object of the live version of the node
 */
function _content_moderation_live_revision($nid) {
  //TODO: this can be costy
  return node_load($nid);
}


/*
 * Determine if this content type is set to be moderated
 */
function _content_moderation_moderate_node_type($type) {
  // Is this content even in moderatation?
  $var = variable_get( "node_options_$type", array(0));
  if( array_search('node_content_moderation',$var) ) {
    return true;
  }
  //else
  return false;
}

/*
 * Determine if this content type is set to be moderated
 */
function _content_moderation_moderate_node_types() {
  $types = node_get_types('types');
  $result= array();
  foreach($types as $type) {
    // Is this content even in moderatation?
    if( _content_moderation_moderate_node_type($type->type)) {
      $result[] = $type->type;
    }
  }

  return $result;
}

/*
 * Getting nid by vid
 */
function _content_moderation_get_nid($vid) {
  return db_result(db_query('select nid from {node_revisions} where vid=%d',$vid));
}

/*
 * Return the proper path to the change-state action
 */
function _content_moderation_change_state_link($vid,$nid) {
  return "moderate/$nid/$vid/change";
}

/*
 * Checking, if the user has the proper rights to change the state of a node, so
 * checking the transition and node type.
 */
function _content_moderation_state_allowed($user,$from_state,$to_state,$node_type) {
  return user_access("content moderation $node_type state '$from_state' to '$to_state'");
}

/*
 * Provides a hook where modules can register there access handler.
 * Example:
 * function mymodul_content_moderation_access($op) {
 *  switch($op) {
 *    case 'view history':
 *      return 'mymodule_access_history'
 *    break;
 *  }
 * }
 *
 * function mymodule_access_history($node) {
 *  return true;
 * }
 */
function _content_moderation_access($op,$node) {
  $access_methods = module_invoke_all('content_moderation_access',$op);
  if(count($access_methods) > 0) {
    if(function_exists($access_methods[0])) {
      return $access_methods[0]($node);
    }
  }
  //else the default
  switch($op) {
    case 'view history':
      return node_access('view',$node);
    break;
  }
}

/*
 * Get a number of latest revisions of a node.
 */
function _content_moderation_get_latest_revisions($nid,$count = 5,$vid =NULL, $exclude = array()) {
  if($vid == NULL) {
    $live = _content_moderation_live_revision($nid);
    $vid = $live->vid;
  }

  $filter = array();
  foreach($exclude as $v) {
    $filter[] = "nr.vid<>$v";
  }
  if(count($filter) > 0) {
    $filter = join(' AND ',$filter);
    $filter = ' AND '.$filter;
  }
  else {
    $filter = '';
  }

  // TODO: important, most probably use db_rewrite_sql here
  $result = db_query("select nr.*,cmrs.state from {node_revisions} as nr LEFT JOIN {content_moderation_revision_state} as cmrs on nr.vid=cmrs.vid where nr.nid=%d AND nr.vid>%d {$filter} order by nr.vid DESC limit %d",$nid,$vid,$count);
  $revs = array();
  while ($rev = db_fetch_object($result)) {
    $revs[] = $rev;
  }
  return $revs;
}

function _content_moderation_get_current_viewed_node() {
  $router_item = menu_get_item($path);
  // if its not a node view, return
  if($router_item['map'][0] != 'node') {
    return NULL;
  }

  $node = $router_item['map'][1];
  // something wrong with the url
  if(!is_object($node)) {
    return NULL;
  }

  if(is_numeric($router_item['map'][2]) && $router_item['map'][3] == 'view') {
    $vid = $router_item['map'][2];

    $node = node_load($node->nid,$vid);
  }
  return $node;
}

/*
 * Small helper for trigger and events
 */
function _content_moderation_node_transition_matrix() {
  static $node_state_matrix = array();
  // chaching
  if(count($node_state_matrix) > 0) {
    return $node_state_matrix;
  }
  $states = _content_moderation_states();
  $types = _content_moderation_moderate_node_types();
  foreach($types as $type) {
    foreach($states as $from_state) {
        $to_states = _content_moderation_next_states($from_state,$type);
        // Values are translated.
        $to_states = array_keys($to_states);
        foreach($to_states as $to_state) {
          $node_state_matrix["{$type}_{$from_state}_{$to_state}"]= t("State of node type @type changed from '@from_state' to '@to_state'", array('@type' => $type, '@from_state' => $from_state, '@to_state' => $to_state));
        }
    }
  }
  return $node_state_matrix;
}