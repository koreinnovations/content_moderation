<?
require_once('content_moderation.workflow.inc');

/*
 * Implementation of hook_menu().
 */
function content_moderation_menu() {
  $items = array();
  $items["moderate/%node/%/change"] = array(
      'title' => 'Change moderation state',
      'type' => MENU_CALLBACK,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('content_moderation_change_state_form',2),
      'access callback' => '_content_moderation_statechange_allowed',
      'access arguments' => array(2)
  );
  $items["node/%node/moderation_history"] = array(
      'title' => 'Moderation history',
      'description' => 'Show the content moderation history',
      'type' => MENU_LOCAL_TASK,
      'page callback' => '_content_moderation_history',
      'page arguments' => array(1),
      'access callback' => '_content_moderation_access',
      'access arguments' => array('view history',1),
  );

  return $items;
}

/*
 * Implementing hook_block
 */
function content_moderation_block($op = "list", $delta = 0, $edit = array()){
  switch($op) {
    case 'list':
      $blocks[0]['info'] = "Content moderation info";
      return $blocks;
    break;
    case 'view':
      switch($delta) {
        case 0:
          $node = menu_get_object('node');
          $live = _content_moderation_live_revision($node->nid);
          // node need to show the block if we are not looking at a revision
          if($node->vid == $live->vid) {
            return "";
          }

          $live_link = l($live->vid,'node/'.$live->nid);
          $state = _content_moderation_current_state($node->vid);

          $m = drupal_get_path('module', 'content_moderation');
          drupal_add_css("$m/css/block.css");

          // All kinds of actions we can do.
          $links['edit_revision'] = "node/{$node->nid}/revisions/{$node->vid}/edit";
          $links['delete_revision'] = "node/{$node->nid}/revisions/{$node->vid}/delete";
          $links['edit_live'] = "node/{$node->nid}/edit";
          $links['edit_state'] = _content_moderation_change_state_link($node->vid,$node->nid);
          $links['compare_with_live'] = "node/{$node->nid}/revisions/view/{$node->vid}/{$live->vid}";
          $links['compare'] = "node/{$node->nid}/revisions";

          $block['subject'] = t("Revision");
          $block['content'] = theme('content_moderation_info_block',$node, $links, $state, $live_link, $live);
          return $block;
        break;
      }
    break;
  }
}


/*
 * Implementation of hook_theme
 */
function content_moderation_theme() {
  return array(
    'content_moderation_info_block' => array(
      'template' => 'content_moderation_info_block',
      'arguments' => array('node' => NULL,'links' => NULL, 'state' => t('none'), 'live_link' => NULL, 'live' => NULL),
    ),
    'content_moderation_node_history' => array(
     'arguments' => array('history' => array()),
    )
  );
}

/**
 * Implementation of hook_help().
 */
function content_moderation_help($path, $arg) {
  switch ($path) {
    case 'admin/help#content_moderation':
      return '<p>'. t("Enables you to moderate the creation of nodes and there further editing. You can have 'Live version' for all visitors and pending revisions which need to be apoved and become the 'Live Version' then") .'</p>';
  }
}

/*
 * Implementation of hook_nodeapi
 */
function content_moderation_nodeapi(&$node, $op, $a3, $a4) {
  global $user;
  $type = $node->type;
  if (!_content_moderation_moderate_node_type($type)) {
    // Dont moderate this content type
    return;
  }
  switch ($op) {
    case 'presave':
      if ( empty($node->nid)) {
        // We backup the original data and use them in the insert hook later.
        $node->body_orig = $node->body;
        $node->teaser_orig = $node->teaser;
        $node->log_orig = $node->log;
        // lets call our alter hook to modify the fake-live version
        _content_moderation_get_modfiy_for_first_revision($node);
        // Now node_save gets called, saving this not into the database
        // and right after it, it calls nodapi using insert. Thats were we save
        // the original node content, which will be then a pending version.
      }
      break;
    case 'insert':
      // We need to clone the node, otherwise later the grants will be assigned to that vid
      $node_real = drupal_clone($node);
      // as we saved the "fake live version" before in presave, lets save the original node here.
      $node_real->content_moderation_update = true;
      _content_moderation_new_node($node_real);
      drupal_set_message(t("Your content has been saved as a pending revision. Click !here to view your revision.", array(
        '!here'=>l(t('here'), "node/$node->nid/revisions/".$node->vid.'/view')
      )), 'warning');
      break;
    case 'update':
      // TODO: We could also use $node->old_vid to restore the live version instead
      // using the relation table.
      $live = _content_moderation_live_revision($node->nid);

      // If live_nid is 0, the system wants us the create a new live revision by defintion of
      // our content_moderation API ( see content_moderation_reset_live_status($nid) ).
      if ($live->vid > 0) {
        // Force the live revision back to saved live -version.
        db_query('UPDATE {node} SET vid = %d WHERE nid = %d', $live->vid, $node->nid);

        if($node->content_moderation_update != true) {
          drupal_set_message(t("Your content has been saved as a pending version. Click !here to view the live version.", array(
          '!here'=>l(t('here'), "node/".$node->nid)
        )), 'warning');
        }
        else {
          // We need to add some miliseconds to the timestamp, otherwise the fake version will be newer then
          // the real pending one
          db_query('UPDATE {node_revisions} SET timestamp = %d WHERE vid = %d',time() +500, $node->vid);
        }
      } else {
        // We dont want to reset, we want to save the current revision as the new live version.
        _content_moderation_set_node_var(array(
          'nid' => $node->nid,'vid' => $node->vid
        ));
        drupal_set_message(t('Your node has been successfuly published as the new live version'));
      }
      break;
    case 'view':
      $live = _content_moderation_live_revision($node->nid);
      $live_vid = $live->vid;

      if ($node->vid != $live_vid) {
        // This is a pending revision.
        $pending = "";
        // Parts of this code are extracted from revision_moderation

        // Get username for the revision rather than the original node.
        $revision_author = user_load($node->revision_uid);
        drupal_set_message(t('You are currently viewing a'.$pending.' revision of this node created on @date by !author.', array(
          '@date'=>format_date($node->revision_timestamp, 'small'),'!author'=>theme('username', $revision_author)
        )));
      }
      break;
  }
}

/*
 * Implementation of hook_perm.
 */
function content_moderation_perm() {
  // TODO: cache this
  // This user right is later used for granting the user the approval of pending version
  // making those version "live".
  $states = _content_moderation_states();
  $types = _content_moderation_moderate_node_types();

  $rigths = array();
  foreach($types as $type) {
    foreach($states as $from_state) {
      dsm($states);
        $to_states = _content_moderation_next_states($from_state,$type);
        foreach($to_states as $to_state) {
          $rigths[] = "content moderation $type state $from_state to $to_state";
        }
    }
  }

  return $rigths;
}

/*
 * Call this method in the form_submit or presave methods to let the updated node
 * be the new live version.
 */
function content_moderation_reset_live_status($nid = NULL) {
  if ($nid == NULL || !is_numeric($nid)) {
    return;
  }

  db_query('DELETE from {content_moderation} WHERE nid = %d', $nid);
}

/*
 * Implementation of hook_modify_first_revision_alter
 */
function content_moderation_content_moderation_modify_first_revision_alter(&$node) {
  $node->body = t('Initial revision - this node is still under moderation');
  $node->log = t('Auto-creating live version of the just created node');
}

/*
 * Implementation of hook_form_alter
 */
function content_moderation_form_node_type_form_alter(&$form, $form_state) {
  $form[ 'workflow' ][ 'node_options' ][ '#options' ][ 'node_content_moderation' ] = t('Moderate revisions');
}

/*
 * Implementation content_moderation_node_history
 * Theming the output of content moderations history table
 */
function theme_content_moderation_node_history($history) {
  $data = array();

  foreach($history as $e) {
    $user = user_load($e->uid);
    $state_class = "state_{$e->state_name}";
    // TODO: proper localized date format
    $data[] = array (
      date('d.m.y - h:i', $e->stamp),                         // date
      l($user->name,"user/{$user->uid}"),                     // Who changed that state?
      "<span class='$state_class'>".ucfirst(t($e->old_state_name)).' -> '.ucfirst(t($e->state_name)).'</span>',             // Transition
      l($e->vid,"node/{$e->nid}/revisions/{$e->vid}/view")   // revision
    );
  }
  return theme('table',
                array(
                      t('Date'),
                      t('Author'),
                      t('Transition'),
                      t('Revision'),
                    )
                ,$data);
}

/*
 * Generating a history overview of a node.
 */
function _content_moderation_history($node) {
  $m = drupal_get_path('module', 'content_moderation');
  drupal_add_css("$m/css/history.css");
  $history = _content_moderation_get_history(array('name' => 'nid', 'value' => $node->nid));
  drupal_set_title(t('History'));
  return theme('content_moderation_node_history',$history);
}

/*
 * Calling our alter hook.
 */
function _content_moderation_get_modfiy_for_first_revision(&$node) {
  //TODO: hooks / alter here
  drupal_alter('content_moderation_modify_first_revision', $node);
}

/*
 * Helper function for creating a new node.
 * Its creating a live version which is a placeholder and
 * moving the real content to a moderated revision
 */
function _content_moderation_new_node(&$node) {
  global $user;
  // save the new live vid
  _content_moderation_set_node_var(array(
    'nid'=>$node->nid,'vid'=>$node->vid
  ));

  // We saved a "pending" version of the node first, lets restore the real content
  // and the real log message.
  $node->body = $node->body_orig;
  $node->teaser = $node->teaser_orig;
  $node->log = $node->log_orig;
  $node->vid = NULL;
  $node->created = NULL;

  // Yes we dont like non-api deep system calls. But we cant use node_save as
  // we would get into a loop.
  node_save($node);
}

/*
 * Database helper.
 */
function _content_moderation_get_node_var($name, $nid, $default = NULL) {
  $result = db_fetch_object(db_query('select `%s` from {content_moderation} where nid=%d', $name, $nid));
  return ($result === false) ? $default : $result->$name;
}

/*
 * Database helper.
 */
function _content_moderation_set_node_var($values, $keys = NULL) {
  if ($keys != NULL) {
    $nid = db_result(db_query("select nid from {content_moderation} where {$keys[0]['name']}=%d", $keys[0]['value']));
    if ($nid === false) {
      $keys = NULL;
    }
  }
  drupal_write_record('content_moderation', $values, $keys);
}

/*
 * Returning the node object of the live version of the node
 */
function _content_moderation_live_revision($nid) {
  //TODO: this can be costy
  return node_load($nid);
}


/*
 * Determine if this content type is set to be moderated
 */
function _content_moderation_moderate_node_type($type) {
  // Is this content even in moderatation?
  $var = variable_get( "node_options_$type", array(0));
  if( array_search('node_content_moderation',$var) ) {
    return true;
  }
  //else
  return false;
}

/*
 * Determine if this content type is set to be moderated
 */
function _content_moderation_moderate_node_types() {
  $types = node_get_types('types');
  $result= array();
  foreach($types as $type) {
      // Is this content even in moderatation?

    if( _content_moderation_moderate_node_type($type->type)) {
      $result[] = $type->type;
    }
  }

  return $result;
}

/*
 * Getting nid by vid
 */
function _content_moderation_get_nid($vid) {
  $result = db_query('select nid from {node_revisions} where vid=%d',$vid);
  $row = db_fetch_object($result);
  return $row->nid;
}

/*
 * Return the proper path to the change-state action
 */
function _content_moderation_change_state_link($vid,$nid) {
  return "moderate/$nid/$vid/change";
}

/*
 * Checking, if the user has the proper rights to change the state of a node, so
 * checking the transition and node type.
 */
function _content_moderation_state_allowed($user,$from_state,$to_state,$node_type) {
  return user_access("content moderation $node_type state $from_state to $to_state");
}

/*
 * Provides a hook where modules can register there access handler.
 * Example:
 * function mymodul_content_moderation_access($op) {
 *  switch($op) {
 *    case 'view history':
 *      return 'mymodule_access_history'
 *    break;
 *  }
 * }
 *
 * function mymodule_access_history($node) {
 *  return true;
 * }
 */
function _content_moderation_access($op,$node) {
  $access_methods = module_invoke_all('content_moderation_access',$op);
  if(count($access_methods) > 0) {
    if(function_exists($access_methods[0])) {
      return $access_methods[0]($node);
    }
  }
  //else the default
  switch($op) {
    case 'view history':
      return node_acess('view',$node);
    break;
  }
}


function content_moderation_views_api() {
  return array('api' => 2.0);
}
